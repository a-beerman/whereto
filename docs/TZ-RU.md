# Техническое задание: WhereTo — городской гид «куда сходить»

## 1. Общее описание проекта

**WhereTo** — это сервис-помощник для поиска мест в городе (рестораны, кафе, бары и т.д.). Пользователь выбирает город, ищет заведение по категории или текстовому запросу, смотрит карточку места и может сохранить или поделиться им. 

### Ключевые отличия от существующих решений
- **Быстрая работа**:  все данные о заведениях хранятся в нашей базе данных, а не запрашиваются каждый раз из внешних сервисов. 
- **Курируемый каталог**: возможность вручную исправлять ошибки (адреса, названия) и скрывать дубликаты без потери при следующем обновлении.
- **Telegram-first**: основной канал взаимодействия — бот в Telegram, простой и быстрый для пользователя.

---

## 2. Цели и задачи

### Фаза 1 (MVP)
**Для кого**:  конечные пользователи (гости и жители города).

**Что делаем**:
- Помогаем быстро найти место в городе (поиск, категории, фильтры).
- Показываем карточку заведения (адрес, рейтинг, фото, часы работы, контакты).
- Даём возможность сохранить понравившиеся места и поделиться ими. 
- Основной интерфейс — бот в Telegram. 

**Что НЕ делаем в Фазе 1** (переносится на Фазу 2):
- Меню/товары
- Бронирование столиков
- Заказы и оплата
- Доставка
- Кабинет для владельцев заведений (B2B)

### Фаза 2 (будущее)
- Подключение заведений к системе (claim/onboarding).
- Запросы на уточнение наличия мест.
- Бронирование, заказы, меню.
- Кабинет владельца (аналитика, промо-кампании).

---

## 3. Принципиальная архитектура системы

### 3.1. Офлайн-каталог мест
Вместо того, чтобы при каждом запросе пользователя обращаться к Google Places API, мы: 
1. **Заранее синхронизируем** данные о заведениях из Google Places в нашу базу данных (по городам).
2. **Обновляем** эти данные периодически (например, раз в сутки или чаще).
3. **Отвечаем пользователю** из своей базы данных — быстро и предсказуемо.

**Почему так**:
- Контроль скорости и стабильности ответа.
- Контроль расходов на внешние API.
- Возможность улучшать данные вручную (исправлять ошибки, скрывать дубли, добавлять теги).
- Устойчивость к сбоям внешних сервисов.

### 3.2. Источники данных

**Основной источник (Фаза 1)**:
- **Google Places API** — первичный источник данных о заведениях

**Дополнительные источники (опционально)**:
- **Парсинг сайтов доставки** — для получения актуальных данных о меню, ценах, наличии
- **Интеграция с собственной ERP** — для заведений, которые уже используют нашу систему

Архитектура поддерживает множественные источники через абстракцию `VenueSource`, что позволяет добавлять новые источники без изменения основной логики.

### 3.3. Компоненты системы

#### A. База данных (каталог)
Хранит: 
- **Города** (список городов, для которых работает сервис).
- **Заведения (Venues)** — основная сущность:  название, адрес, координаты, категории, рейтинг, фото, часы работы, статус (активно / скрыто / дубликат).
- **Источники (VenueSource)** — связь с внешними системами (например, Google `place_id`), чтобы знать, откуда пришла информация и когда она обновлялась. 
- **Переопределения (VenueOverrides)** — ручные правки оператора (исправленное название, адрес, скрытие дубля), которые не затираются при следующей синхронизации.

#### B. Воркер синхронизации (Ingestion Job)
Задача:
- Для заданного города запросить данные из Google Places (по категориям, по географическим границам).
- Нормализовать полученные данные в нашу модель. 
- Создать или обновить записи в базе данных. 
- Найти и пометить дубликаты (по одинаковому `place_id`, по близости координат + похожести названия).
- Сохранить метрики (сколько мест получили, сколько создали, сколько обновили, сколько ошибок).

Запускается: 
- Автоматически по расписанию (например, 1 раз в сутки ночью).
- Вручную по команде оператора (для срочного обновления).

#### C. API (Backend)
Предоставляет:
- **Поиск заведений** (`GET /venues`):
  - Фильтры:  текстовый запрос, категория, географическая область (bbox или радиус от точки), минимальный рейтинг, открыто сейчас (опционально).
  - Пагинация результатов. 
- **Карточка заведения** (`GET /venues/{id}`):
  - Полная информация о месте. 
- **Избранное** (опционально на сервере):
  - Сохранить/удалить место в избранном пользователя.
  - Список избранного.
- **Групповое планирование** (опционально в Фазе 1):
  - Создание плана, присоединение, выбор предпочтений, голосование. 

Все запросы пользователей обслуживаются **только из нашей базы данных**. 

#### D. Telegram-бот
Основной интерфейс для пользователей:
- Выбор города. 
- Выбор категории (Еда / Кофе / Бар) или текстовый поиск.
- Список результатов (пагинация).
- Карточка заведения: 
  - Название, адрес, рейтинг, категория, расстояние, часы работы. 
  - Кнопки:  Сохранить, Поделиться, Маршрут (ссылка на карты), Позвонить (если есть), Сайт (если есть).
- Просмотр избранного. 
- (Опционально) Групповое планирование:  команда `/plan` для создания плана похода с друзьями, голосование за места.

#### E. Mini App (опционально в Фазе 1)
Веб-интерфейс внутри Telegram (или отдельно):
- Зона для пользователей (`/c/*`): поиск, карточки, избранное. 
- Зона для заведений (`/m/*`) — **Фаза 2**, не в MVP. 

---

## 4. Как работает система (end-to-end)

### 4.1. Наполнение каталога (ежедневно, автоматически)
1. Воркер синхронизации просыпается по расписанию (например, в 3:00 ночи по местному времени города).
2. Загружает конфигурацию города (границы, центр, список категорий для синхронизации).
3. Для каждой категории: 
   - Запрашивает список мест из Google Places API (с пагинацией).
   - Нормализует данные (приводит к единой структуре).
4. Для каждого полученного места:
   - Проверяет, есть ли уже запись с таким `place_id` в нашей базе.
   - Если есть — обновляет (если данные изменились).
   - Если нет — создаёт новую запись. 
5. Запускает дедупликацию: 
   - Ищет заведения с одинаковым `place_id` (это дубль из разных запросов, должен быть один).
   - Ищет заведения, близкие по координатам (<50 метров) и с похожим названием — вероятный дубликат.
   - Ищет заведения с совпадающим адресом — ещё один признак дубля.
   - Выбирает "мастер-запись" (наиболее полную), остальные помечает как `duplicate/hidden`.
6. Применяет ручные переопределения (VenueOverrides):
   - Если оператор вручную исправил название или скрыл дубль — это должно остаться даже после синхронизации. 
7. Сохраняет метрики (длительность, количество созданных/обновлённых/ошибок).

### 4.2. Пользовательский сценарий (поиск и просмотр)
1. Пользователь открывает бота в Telegram.
2. Бот спрашивает: "В каком городе ищем места?"
   - Пользователь выбирает город (например, Кишинёв).
3. Бот предлагает:  "Что хочешь?"
   - Кнопки: Еда / Кофе / Бар / Поиск. 
4. Пользователь выбирает "Кофе" или вводит текст "пицца центр".
5. Бот отправляет запрос в API:  `GET /venues?city=chisinau&q=пицца+центр` (или `category=coffee`).
6. API:
   - Ищет в базе данных по текстовому запросу (полнотекстовый поиск по названию/адресу).
   - Фильтрует по категории (если выбрана).
   - Сортирует по релевантности (расстояние, рейтинг).
   - Возвращает список (первые 10 результатов).
7. Бот показывает список заведений (краткая информация + кнопки для перехода к деталям или следующей странице).
8. Пользователь нажимает на заведение. 
9. Бот отправляет запрос:  `GET /venues/{id}`.
10. API возвращает полную карточку (с учётом переопределений, если они есть).
11. Бот показывает карточку: 
    - Название, адрес, рейтинг, категория, расстояние, часы работы.
    - Кнопки: "Сохранить", "Поделиться", "Маршрут", "Позвонить", "Сайт".
12. Пользователь нажимает "Сохранить": 
    - Если избранное хранится на сервере:  бот отправляет `POST /saved/{venueId}`.
    - Если на клиенте: бот сохраняет в локальную сессию.
13. Пользователь может вернуться к списку или искать дальше. 

### 4.3. Ручное курирование (оператор)
1. Оператор видит в системе дубликат или ошибку в данных (например, неверный адрес).
2. Через админ-панель (или скрипт/команду) создаёт запись в `VenueOverrides`:
   - Исправляет название или адрес.
   - Помечает заведение как скрытое. 
   - Добавляет заметку (причину).
3. При следующем показе пользователю:
   - API применяет переопределение поверх данных из `Venue`.
   - Пользователь видит исправленную информацию.
4. При следующей синхронизации:
   - Воркер обновляет `Venue` из Google Places (если данные изменились).
   - НО переопределение остаётся в силе, т.к. хранится в отдельной таблице.

---

## 5. Модель данных (упрощённо)

### City (Город)
- Идентификатор
- Название
- Код страны
- Центр (широта, долгота)
- Границы (опционально)
- Часовой пояс
- Активен ли

### Venue (Заведение)
- Идентификатор
- Город (ссылка на City)
- Название
- Адрес
- Координаты (широта, долгота)
- Категории (список тегов)
- Рейтинг, количество отзывов
- Фотографии (ссылки или идентификаторы)
- Часы работы (структура или строка)
- Статус (активно / скрыто / дубликат)
- Дата создания, дата обновления

### VenueSource (Источник)
- Идентификатор
- Заведение (ссылка на Venue)
- Источник (например, "google_places", "delivery_site", "erp")
- Внешний ID (например, Google `place_id`)
- Время последней синхронизации
- Хеш данных (для определения изменений)

### VenueOverrides (Переопределения)
- Заведение (ссылка на Venue)
- Переопределённое название (если нужно)
- Переопределённый адрес (если нужно)
- Переопределённые координаты (если нужно)
- Переопределённые категории (если нужно)
- Флаг "скрыто" (если нужно скрыть заведение)
- Заметка (для оператора)
- Кем и когда обновлено

---

## 6. Пользовательские роли и сценарии

### Роль:  Конечный пользователь (гость/житель города)
**Сценарий 1: Найти кофейню рядом**
1. Открыть бота. 
2. Выбрать город "Кишинёв". 
3. Нажать "Кофе". 
4. Просмотреть список (5–10 мест).
5. Открыть карточку понравившегося места.
6. Нажать "Маршрут" (открывается Google/Yandex Maps).
7. (Опционально) Нажать "Сохранить" — место добавляется в избранное. 

**Сценарий 2: Поиск по запросу**
1. Открыть бота.
2. Выбрать город. 
3. Нажать "Поиск".
4. Ввести "пицца центр".
5. Получить список результатов. 
6. Открыть карточку, посмотреть рейтинг, адрес, часы работы.
7. Поделиться ссылкой с другом. 

**Сценарий 3: Посмотреть избранное**
1. Открыть бота.
2. Нажать "Избранное". 
3. Увидеть список сохранённых мест.
4. Открыть любое из них. 

**Сценарий 4 (опционально): Групповое планирование**
1. Пользователь в групповом чате пишет `/plan`.
2. Бот задаёт вопросы:  когда, во сколько, район, бюджет, формат (ужин/бар/кофе).
3. Создаётся план, другие участники группы нажимают "Join".
4. Бот генерирует список из 3–5 подходящих мест (из каталога).
5. Участники голосуют (один голос).
6. Бот подводит итог (победитель или тай-брейк).

### Роль: Оператор/редактор каталога (внутренний)
**Сценарий:  Исправить ошибку в данных**
1. Обнаружить дубликат или неверный адрес в каталоге.
2. Открыть админ-панель (или выполнить команду).
3. Создать переопределение: 
   - Исправить адрес.
   - Скрыть дубль. 
   - Добавить заметку.
4. Сохранить. 
5. Проверить, что пользователи теперь видят исправленную версию.

**Сценарий: Запустить синхронизацию вручную**
1. Открыть панель управления воркерами.
2. Выбрать город.
3. Нажать "Синхронизировать сейчас".
4. Дождаться завершения. 
5. Просмотреть метрики (сколько мест обновлено, сколько ошибок).

---

## 7. Нефункциональные требования

### 7.1. Производительность
- **Поиск заведений** (`GET /venues`): p95 latency < 500ms.
- **Карточка заведения** (`GET /venues/{id}`): p95 latency < 300ms.
- **Бот**:  ответ пользователю в течение 1–2 секунд (с учётом сети Telegram).

### 7.2. Надёжность
- Синхронизация должна завершаться успешно ≥ 95% запусков.
- При сбое синхронизации — логирование, алерт, retry.
- API должен работать, даже если Google Places недоступен (читаем из своей базы).

### 7.3. Масштабируемость (на старте)
- Поддержка 1 города в MVP.
- Архитектура позволяет добавить города без переписывания (город — отдельная конфигурация и отдельный запуск воркера).
- База данных:  Postgres + PostGIS для гео-индексов, полнотекстовый поиск.

### 7.4. Безопасность
- Аутентификация пользователей через Telegram (`from. id` в боте, `initData` в Mini App).
- Для вызовов API из бота:  служебный токен или подписанный запрос (уровень MVP).
- Ручные правки (VenueOverrides) доступны только операторам (авторизация по ролям).

### 7.5. Наблюдаемость
- Логирование всех запросов API (с уровнями:  info, warn, error).
- Метрики: 
  - Продуктовые: количество поисков, открытий карточек, сохранений, шерингов.
  - Технические: latency API, успешность синхронизации, количество обновлённых мест, количество дублей.
- Алерты при сбое синхронизации или превышении SLO по latency.

---

## 8. Ограничения и допущения

### 8.1. Ограничения MVP (Фаза 1)
- **Один город** на старте (Кишинёв).
- **Нет меню/товаров**:  показываем только общую информацию о заведении.
- **Нет бронирования**: пользователь может позвонить или открыть сайт самостоятельно. 
- **Нет B2B кабинета**: владельцы заведений не могут редактировать свои карточки. 
- **Избранное**: может быть реализовано локально (в боте/сессии) без синхронизации между устройствами (для ускорения MVP).

### 8.2. Допущения
- Google Places API является достаточно полным источником данных для Кишинёва (рестораны, кафе, бары).
- Большинство пользователей будут взаимодействовать через Telegram-бот (не через веб).
- Ежедневного обновления каталога достаточно (часы работы и статус "открыто сейчас" могут быть неточными, если заведение изменило режим в течение дня).
- Дедупликация по гео-расстоянию (<50 метров) + похожести названия даст приемлемое качество (ложноположительных дублей < 5%).

---

## 9. Метрики успеха (как измеряем результат)

### Продуктовые метрики
- **Activation**:  доля пользователей, которые выбрали город и открыли ≥1 карточку в первую сессию (цель ≥ 60%).
- **Search success**: доля поисковых сессий, где пользователь открыл хотя бы одну карточку (цель ≥ 70%).
- **Save rate**: доля пользователей, сохранивших ≥1 место за неделю (цель ≥ 20%).
- **Return rate D7**: доля пользователей, вернувшихся в течение 7 дней (цель ≥ 30%).

### Метрики качества каталога
- **Coverage**: доля популярных категорий (еда, кофе, бар), покрытых в городе (цель 100% для основных категорий).
- **Freshness**: медианное время с момента последнего обновления заведения (цель ≤ 24 часа).
- **Dup rate**: доля дублей, обнаруженных и скрытых (должна снижаться со временем, цель < 3%).
- **Override rate**: доля заведений с ручными правками (индикатор качества автоматической синхронизации; цель < 10%).

### Технические метрики
- **p95 latency API** для поиска и карточки (цель < 500ms / 300ms).
- **Ingestion success rate**: ≥ 95%. 
- **Стоимость синка на город** (время + запросы к Google Places) — должна быть предсказуемой и укладываться в бюджет.

---

## 10. План работ (high-level)

### Month 1 (M1): Офлайн-каталог + B2C ядро
1. **Модель данных**: City, Venue, VenueSource, VenueOverrides (Postgres + PostGIS).
2. **Воркер синхронизации**:
   - Синк 1 города (Кишинёв) из Google Places.
   - Минимальная дедупликация (по place_id, geo+name).
3. **API**:
   - `GET /venues` (поиск/фильтры:  q, category, bbox/radius, minRating).
   - `GET /venues/{id}` (карточка).
4. **Бот**: 
   - Выбор города + категории + поиск.
   - Список результатов (пагинация) + открыть карточку.
   - Действия в карточке:  "Сохранить", "Поделиться", "Маршрут/Позвонить/Сайт".
   - Избранное (минимум).
5. **Observability**:
   - Метрики:  search → open card, save, share. 
   - p95 latency для поиска/карточки.
6. **(Опционально) Групповое планирование `/plan`**: если оставляем в M1.

### Month 2 (M2): Качество каталога + B2C polish
1. **Улучшение дедупликации** + инструмент "пометить дубликат/скрыть". 
2. **Scheduled refresh** (cadence) + ручной ресинк.
3. **Админ-команды** (минимум): hide/unhide, edit overrides, resync.
4. **Улучшения поиска/ранжирования**:  distance, openNow, ratingCount.
5. **Подборки/категории** (простые коллекции).
6. **Улучшенный поиск** (синонимы/опечатки — минимально).
7. **(Опционально) Miniapp B2C** (`/c/*`): категории + поиск + карточка + избранное.

### Phase 2 (после M2): B2B + бронирования + меню
- Онбординг заведений (claim/merchant cabinet).
- Запросы на уточнение наличия мест (availability requests).
- Бронирование/заказы/меню — отдельные итерации.

---

## 11. Риски и способы снижения

### Риск 1: Превышение бюджета на Google Places API
**Описание**: Если синхронизация требует слишком много запросов, стоимость может быть высокой.  
**Снижение**:
- Оптимизировать стратегию обхода города (минимум overlap).
- Использовать инкрементальные обновления (только изменившиеся места).
- Ограничить частоту синхронизации (1 раз в сутки вместо чаще).
- Отслеживать стоимость, настроить лимиты в Google Cloud.

### Риск 2: Плохое качество дедупликации
**Описание**: Система создаёт слишком много дублей или, наоборот, склеивает разные заведения.  
**Снижение**:
- Начать с консервативных правил (только по place_id).
- Постепенно добавлять geo+name heuristics, отслеживая false positives.
- Дать оператору инструмент для ручной разметки дублей и не-дублей. 
- Использовать feedback loop:  оператор помечает дубль → система учитывает при следующем ранке.

### Риск 3: Несвежие данные (часы работы, статус "открыто")
**Описание**: Заведение изменило часы работы, но синхронизация была вчера.  
**Снижение**:
- В MVP принять, что данные могут быть неточными (это компромисс ради скорости и стоимости).
- В карточке указывать "по данным на [дата последней синхронизации]". 
- В Фазе 2: добавить "сообщить об ошибке" и приоритизировать ресинк популярных мест. 

### Риск 4: Низкая вовлечённость пользователей
**Описание**: Пользователи не находят нужные места или не возвращаются.  
**Снижение**:
- A/B тестирование UX бота (порядок кнопок, тексты).
- Сбор фидбека (кнопка "не нашёл нужное место").
- Улучшение ранжирования (дистанция, рейтинг, openNow).
- Добавление подборок/рекомендаций (Phase 2).

### Риск 5: Compliance / Legal
**Описание**: Использование данных Google Places может требовать соблюдения условий (attribution, ограничения на кэширование).  
**Снижение**:
- Изучить Terms of Service Google Places API.
- Указать attribution в карточках (если требуется).
- Убедиться, что хранение данных в нашей БД не нарушает ToS (обычно разрешено для кэширования с разумным TTL и attribution).

---

## 12. Definition of Done (MVP готов к запуску, когда...)

1. **Один город синхронизирован end-to-end** (Google Places → наша БД) с повторяемыми запусками воркера.
2. **`GET /venues` работает стабильно**:  поиск по запросу/категории + гео-фильтр + пагинация возвращает корректные результаты.
3. **`GET /venues/{id}` возвращает полную карточку** (с применением переопределений, если они есть).
4. **Бот поддерживает полный flow**: город → browse/search → список → карточка → save/share. 
5. **Дедупликация и переопределения работают**: дубли помечены, ручные правки переживают синхронизацию.
6. **Метрики видны**: метрики синхронизации (длительность, количество мест, ошибки) и метрики API (latency) доступны для мониторинга.
7. **Scope Фазы 2 НЕ реализован** в Фазе 1 (нет меню, бронирований, B2B кабинета).

---

## 13. Приложения и ссылки на детали

Для технической реализации и детализации: 
- [`docs/FINAL-SPEC.md`](FINAL-SPEC.md) — финальная спецификация (implementation-ready, на английском).
- [`docs/PRD-RU.md`](PRD-RU.md) — продуктовый документ (цели, метрики, scope).
- [`docs/CATALOG-RU.md`](CATALOG-RU.md) — модель каталога и ingestion.
- [`docs/Backlog-M1-M2-RU.md`](Backlog-M1-M2-RU.md) — детальный бэклог по месяцам. 
- [`docs/ARCHITECTURE.md`](ARCHITECTURE.md) — архитектура Phase 1 (компоненты, data flow).
- [`docs/Bot-Copy-RU.md`](Bot-Copy-RU.md) — тексты бота. 

---

**Конец технического задания.**

